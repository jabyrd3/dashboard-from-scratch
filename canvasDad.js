'use strict';

/* --------

# CANVASDAD

A registry style singleton for keeping track of various canvas drawings and
automatically setting up / destroying window resize listeners so that your
canvas' can behave responsively based on the width of the parent element
you pass in when you create it

## methods and usage

### create (parent, render, context)
  this method creates and injects a canvas element into the html node provided
  as the first function argument. It then calls the render function provided as
  the second input. This render function is called with (canvas, context), which
  are the bare html5 canvas/context apis, respectively. The context is given
  an 'identifier' parameter, which is used internally to reference that
  particular graph. Make sure to reference the return of the create function
  in your context so that you can reference this identifier when you
  call other methods.

### update (context identifier)
  this method takes one argument: a context identifier generated by the create
  method. It grabs the context, canvas, render function, etc, and calls the
  render function with the new size of the parent element. This is what
  the automatic resize logic uses internally. You should call this directly if
  the data referenced in your render function has been updated. You'd also call
  this directly if you were looking to make a render/game loop out of a render
  function. I cannot guarantee that this would be performant, though.

### destroy (context identifier)
  this method takes a context identifier. it the deregisters the resize listener
  , removes the element from the parent node, and deletes the record from the
  singletons internal registry. ALWAYS CALL THIS WHEN YOUR CHART/GRAPH/GAME IS
  NO LONGER NEEDED.

---------- */

let registry = {};
window.CanvasDad = function (){
  // basic setup, get pixel ratio for system
  this.pixelRatio = (function () {
    var ctx = document.createElement('canvas').getContext('2d'),
      dpr = window.devicePixelRatio || 1,
      bsr = ctx.webkitBackingStorePixelRatio ||
        ctx.mozBackingStorePixelRatio ||
        ctx.msBackingStorePixelRatio ||
        ctx.oBackingStorePixelRatio ||
        ctx.backingStorePixelRatio ||
        1;
    return dpr / bsr;
  })();

  this.create = (parent, render) => {
    let canvas = document.createElement('canvas');
    let [w, h] = [parent.clientWidth, parent.clientHeight];
    let context = canvas.getContext('2d');
    context.identifier = Object.keys(registry).length;
    let listener = window.addEventListener('resize', () => {
      this.update(context.identifier);
    });
    canvas.width = w * this.pixelRatio;
    canvas.height = h * this.pixelRatio;
    canvas.style.height = `${h}px`;
    canvas.style.width = `${w}px`;
    parent.appendChild(canvas);
    context.scale(this.pixelRatio, this.pixelRatio);
    registry[context.identifier] = {
      parent,
      canvas,
      render,
      listener,
      context
    };
    render(canvas, context);
    return context;
  };

  this.update = (id) => {
    let {parent, canvas, context, render} = registry[id];
    let [w, h] = [
      parent.clientWidth,
      parent.clientHeight,
    ];
    canvas.width = w * this.pixelRatio;
    canvas.height = h * this.pixelRatio;
    context.scale(this.pixelRatio, this.pixelRatio);
    canvas.style.height = `${h}px`;
    canvas.style.width = `${w}px`;
    context.clearRect(0, 0, canvas.width, canvas.height);
    render(canvas, context);
  };

  this.animateTick = (id) => {
    let {canvas, context, render} = registry[id];
    context.clearRect(0, 0, canvas.width, canvas.height);
    render(canvas, context);
  };

  this.destroy = (id) => {
    let canvas = registry[id].parent;
    canvas.parent.removeChild(canvas.canvas);
    window.removeEventListener(canvas.listener);
    delete registry[id];
  };

  return this;
};
